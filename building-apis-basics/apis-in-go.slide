Building APIs (in Go)
ProgSCon London
22 Apr 2016
Tags: APIs, Golang, Appengine

Mat Ryer
https://matryer.com/
@matryer

* About me

- Using Go for six years (since before BETA)
- Author of Go Programming Blueprints
- Working at [[http://GrayMeta.com]]
- Wrote [[https://downlist.io]], [[https://route.run]], [[https://disclaimr.org]] - in Go running on App Engine
- Made BitBar app for Mac OS X - [[https://getbitbar.com]] another Go/AppEngine project
- Blog about Go on [[http://matryer.com]]

.image gopher-mat.png

* Purpose of this talk

- Learn Go in 5 minutes
- Find out why Go is great for Building APIs
- Explore Google App Engine as a NoOps hosting option

Goal is to convince you to build your next API in Go.

* Go in 5 minutes

* Why Go?

- Simplicity
- Very little 'magic'
- Standard format for code
- Concurrency built in
- Testing a first class concern
- Amazing community
- Compiles like lightning to single binary
- Impressive standard library

.image trend.png 200 _

* Go code

.code greeter/greeter.go /START OMIT/,/END OMIT/

* Using Greeter

.play greeter-demo/greeter.go /START OMIT/,/END OMIT/

* Building APIs in Go

* `http` package from the standard library

Meet the `http.Handler` interface:

  type Handler interface {
    ServeHTTP(w http.ResponseWriter, r *http.Request)
  }
  
  http.Handle("/path", myHandler)

`http.HandlerFunc` is even easier:

  http.HandleFunc("/path", func(w http.ResponseWriter, r *http.Request) {

  })

* Production ready example

.code production_ready.go

* http.ResponseWriter

  // A ResponseWriter interface is used by an HTTP handler to
  // construct an HTTP response.
  type ResponseWriter interface {

    Header() Header
    Write([]byte) (int, error)
    WriteHeader(int)

  }

from [[http://golang.org/src/net/http/server.go?s=1517:2599#L48]]

* http.Request

`http.Request` contains everything you need to know about the request. 

- `r.Method` - HTTP method (`GET`, `POST`, `PUT`, `PATCH`, `DELETE` etc.)
- `r.URL.Path` - Request path (`/things/123`)
- `r.URL.String()` - Full URL
- `r.URL.Query()` - Query parameters (`q=something&p=2`)
- `r.Body` - `io.ReadCloser` of the request body

More at [[https://golang.org/pkg/net/http/#Request]]

* Middleware

  func Log(h http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {

      // before the handlers

      // call handler
      h.ServeHTTP(w, r)

      // after the handlers

    })
  }

* Adapters

  // Adapter wraps an http.Handler with additional
  // functionality.
  type Adapter func(http.Handler) http.Handler
  
  func Logging(l *log.Logger) Adapter {
    return func(h http.Handler) http.Handler {
      return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // before the handlers
        h.ServeHTTP(w, r)
        // after the handlers
      })
    }
  }

To use it:

  withLogs := Logging(l)
  http.Handle("/one", withLogs(handleOne))
  http.Handle("/two", withLogs(handleTwo))
  http.Handle("/three", withLogs(handleThree))
  
* Google App Engine

- Push Go code
- Google deploy and scale for us
- Go code starts up very quickly
- Generous free quota
- Capable of massive scale when the app takes off
- Services: Datastore, Google Accounts, Message Queues, Email, Logging, etc.

More at [[https://cloud.google.com/appengine/docs]]

* Let's build an API for comments

* MVP

- API to accept comments via `POST` `/comments`
- Deliver comments via `GET` `/comments`
- Deploy to Google App Engine
- Use Google's Datastore to store comment data

Start your timers, this is quick...

* Setup project

  /comments
    app.yaml
    main.go

`app.yaml`

  application: comments-demo
  version:     1
  runtime:     go
  api_version: go1
  handlers:
  - url: /.*
    script: _go_app

`main.go`

  package comments
  import "net/http"
  func init() {
  	http.HandleFunc("/comments", handleComments)
  }

* comments.go

Create a `struct` to hold each comment

  package comments

  import (
    "time"
    "google.golang.org/appengine/datastore"
  )

  type Comment struct {
  	Key     *datastore.Key `json:"id" datastore:"-"`
  	Body    string         `json:"body"`
  	Author  string         `json:"author"`
  	Created time.Time      `json:"created"`
  }

* Handler

`http.HandlerFunc` that routes based on HTTP method

  func handleComments(w http.ResponseWriter, r *http.Request) {
  	ctx := appengine.NewContext(r)
  	switch r.Method {
  	case "GET":
  		handleGetComments(ctx, w, r)
  	case "POST":
  		handleAddComment(ctx, w, r)
  	}
  }

* Handle reading comments

  func handleGetComments(ctx context.Context, w http.ResponseWriter, r *http.Request) {
  	comments := make([]Comment, 0)

  	keys, err := datastore.NewQuery("Comment").Order("-Created").GetAll(ctx, &comments)
  	if err != nil {
  		http.Error(w, err.Error(), http.StatusInternalServerError)
  		return
  	}

  	for i, key := range keys {
  		comments[i].Key = key
  	}

  	err = json.NewEncoder(w).Encode(comments)
  	if err != nil {
  		http.Error(w, err.Error(), http.StatusInternalServerError)
  		return
  	}
  }

* Handle adding comments

  func handleAddComment(ctx context.Context, w http.ResponseWriter, r *http.Request) {
  	var comment Comment
  	err := json.NewDecoder(r.Body).Decode(&comment)
  	if err != nil {
  		http.Error(w, err.Error(), http.StatusBadRequest)
  		return
  	}
  	comment.Created = time.Now()
  	commentKey := datastore.NewIncompleteKey(ctx, "Comment", nil)
  	commentKey, err = datastore.Put(ctx, commentKey, &comment)
  	if err != nil {
  		http.Error(w, err.Error(), http.StatusInternalServerError)
  		return
  	}
  	comment.Key = commentKey
  	w.WriteHeader(http.StatusCreated)
  	err = json.NewEncoder(w).Encode(comment)
  	if err != nil {
  		http.Error(w, err.Error(), http.StatusInternalServerError)
  		return
  	}
  }

* That's it

* Local testing and deployment

Google App Engine SDK provides `goapp` command.

Run local dev server:

  goapp serve

Deploy to Google App Engine:

  goapp deploy

* Using the API

Adding comments with `curl`:

  $ curl -XPOST -d '{"body":"Hi Progscon","author":"Mat"}' http://localhost:8080/comments

  {
  	"id":"ag9kZXZ-Y29tbWVudHNhcHByFAsSB0NvbW1lbnQYgICAgICAgAoM",
  	"body":"Hi Progscon",
  	"author":"Mat",
  	"created":"2016-04-21T17:32:50.203193915Z"
  }

* Viewing comments data in a browser

Open [[http://localhost:8080/comments]]

  [{
  	"id": "ag9kZXZ-Y29tbWVudHNhcHByFAsSB0NvbW1lbnQYgICAgICAgAsM",
  	"body": "I didnt even get chance to explain channels etc.",
  	"author": "Mat",
  	"created": "2016-04-21T17:51:20.438461Z"
  }, {
  	"id": "ag9kZXZ-Y29tbWVudHNhcHByFAsSB0NvbW1lbnQYgICAgICAgAkM",
  	"body": "I hope people build APIs with Go",
  	"author": "Mat",
  	"created": "2016-04-21T17:50:58.884083Z"
  }, {
  	"id": "ag9kZXZ-Y29tbWVudHNhcHByFAsSB0NvbW1lbnQYgICAgICAgAoM",
  	"body": "Hi Progscon",
  	"author": "Mat",
  	"created": "2016-04-21T17:32:50.203193Z"
  }]

* It's real

The API code has been deployed to Google App Engine.

Please send your comments now:

  curl -XPOST -d '{"body":"Hi Progscon","author":"Mat"}' http://comments-demo.appspot.com/comments

See what others are posting by visiting [[http://comments-demo.appspot.com/comments]]

* Community

Go has one of the most inclusive and patient communities in tech.

- Slack: [[https://gophers.slack.com]]
- golang-nuts Google Groups
- @womenwhogo

* Summary

- Go's simplicity makes writing APIs easy
- Write functions that accept `http.ResponseWriter` and `http.Request`
- Google App Engine is an ops-less way of deploying code
- If our app takes off, Google can scale it for us

What we did:

- Built a real RESTful Comments API that speaks JSON
- Used Go's standard library to handle requests
- Routed POST and GET requests differently
- Added code to create comments and save them in Google App Engine's Datastore
- Added code to query comments from the datastore and render as JSON

Code was written last night in 10 minutes.
